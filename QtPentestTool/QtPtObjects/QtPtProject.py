# Copyright (c) 2019 vonKrafft <contact@vonkrafft.fr>
# 
# This file is part of QtPentestTool.
# 
# This file may be used under the terms of the GNU General Public License
# version 3.0 as published by the Free Software Foundation and appearing in
# the file LICENSE included in the packaging of this file. Please review the
# following information to ensure the GNU General Public License version 3.0
# requirements will be met: http://www.gnu.org/copyleft/gpl.html.
# 
# This file is provided AS IS with NO WARRANTY OF ANY KIND, INCLUDING THE
# WARRANTY OF DESIGN, MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.

from PyQt5 import QtCore

from .. import QtPtObjects

import glob
import json
import os
import re
import shutil
import subprocess


class QProject(object):
    """ Model object for a project """

    DATA_DEFAULT = { 'name': 'Unknown client', 'client': 'Untitled', 'date': '1970-01-01', 'accounts': [], 'targets': [] }

    def __init__(self, folder, database = 'project.json'):
        """ Class constructor

        Keyword arguments:
        folder -- the folder in which to save information and project's resources
        database -- the file to store project's information (default 'project.json')
        """
        self.database = os.path.join(os.path.abspath(folder), os.path.basename(database))
        self.data = self.DATA_DEFAULT
        self.targets, self.accounts, self.vulns = [], [], []

    def read(self):
        """ Retrieve project's information from the database file
        The file has to exist and be JSON

        Return:
        the current class
        """
        if os.path.isfile(self.database):
            with open(self.database, 'r') as file:
                self.data = { **self.DATA_DEFAULT, **json.load(file) }
            for target in self.data['targets']:
                if 'hostname' in target:
                    self.targets.append(QtPtObjects.QTarget(**target))
            for account in self.data['accounts']:
                if 'username' in account:
                    self.accounts.append(QtPtObjects.QAccount(**account))
            self.loadVulnerabilities()
        return self

    def write(self):
        """ Save project's information into the database file
        The data will be stored in JSON and the file will be overwritten

        Return:
        the current class
        """
        self.data['targets'] = [target.dict() for target in self.targets]
        self.data['accounts'] = [account.dict() for account in self.accounts]
        with open(self.database, 'w') as file:
            json.dump(self.data, file, indent=4)
        return self

    def create(self, workdir = '/tmp', database = 'project.json'):
        """ Create a new project

        Keyword arguments:
        folder -- the folder in which to create project's folder (default '/tmp')
        database -- the file to store project's information (default 'project.json')

        Return:
        True if the project was created, False otherwise
        """
        folder = '{date}-{client}-{name}'.format(
            date=re.sub(r'[^0-9]+', '', self.get('date', self.DATA_DEFAULT.get('date'))),
            client=QProject.sanitizeProjectFolder(self.get('client', self.DATA_DEFAULT.get('client'))),
            name=QProject.sanitizeProjectFolder(self.get('name', self.DATA_DEFAULT.get('name')))
        ).upper()
        self.database = os.path.join(os.path.abspath(workdir), folder, os.path.basename(database))
        if not os.path.isdir(self.dirname()):
            os.makedirs(self.dirname(), exist_ok=True)
            os.makedirs(os.path.join(self.dirname(), 'burp'), exist_ok=True)
            os.makedirs(os.path.join(self.dirname(), 'downloads'), exist_ok=True)
            os.makedirs(os.path.join(self.dirname(), 'scans'), exist_ok=True)
            os.makedirs(os.path.join(self.dirname(), 'screenshots'), exist_ok=True)
            os.makedirs(os.path.join(self.dirname(), 'shell-logs'), exist_ok=True)
            os.makedirs(os.path.join(self.dirname(), 'vulns'), exist_ok=True)
            self.write()
            return True
        return False

    def export(self, format = 'tar'):
        """ Create an archive file (such as zip or tar)

        Keyword arguments:
        format -- the archive format (default 'tar')

        Return:
        the archive's name
        """
        if format in [f[0] for f in shutil.get_archive_formats()]:
            return shutil.make_archive(self.dirname(), format, os.path.dirname(self.dirname()), self.basename())
        return None

    def get(self, key, default = None):
        """ Getter for a project property

        Keyword arguments:
        key -- the name of the property
        default -- the value to return if the property does not exist

        Return:
        the value of the requested property
        """
        return self.data.get(key, default)

    def set(self, key, value):
        """ Setter for a project property

        Keyword arguments:
        key -- the name of the property
        value -- the value of the property
        """
        self.data[key] = value

    def basename(self):
        """ Return the base name of the project's pathname

        Return:
        the base name of the database file
        """
        return os.path.basename(self.dirname())

    def dirname(self):
        """ Return the directory name of the project's pathname

        Return:
        the directory name of the database file
        """
        return os.path.dirname(os.path.abspath(self.database))

    def relpath(self, path):
        """ Return a relative filepath to path from the project's folder

        Return:
        a relative filepath to path from the directory name of the database file
        """
        return os.path.relpath(path, self.dirname())

    @staticmethod
    def enum(root, database = 'project.json'):
        """ List all the directories in `root` that have the `database` file

        Keyword arguments:
        root -- the folder in which to search for projects
        database -- the name of the database file that defines a project as such (default 'project.json')

        Return:
        an array of the found projects
        """
        root = os.path.abspath(root)
        if os.path.isdir(root):
            return [os.path.dirname(f) for f in glob.glob(os.path.join(root, '*', database))]
        return []

    @staticmethod
    def isProject(folder, database = 'project.json'):
        """ Check if the given folder is a valid project database

        Keyword arguments:
        folder -- the folder in which to save information and project's resources
        database -- the file to store project's information (default 'project.json')

        Return:
        True if the given folder contains the 'database' file, False otherwise
        """
        if os.path.isfile(os.path.join(os.path.abspath(folder), os.path.basename(database))):
            try:
                with open(os.path.join(os.path.abspath(folder), os.path.basename(database)), 'r') as file:
                    data = json.load(file)
                return all(key in data for key in ( 'name', 'client', 'date', 'accounts', 'targets' ))
            except json.JSONDecodeError:
                return False
        return False

    def getScanDir(self):
        return os.path.join(self.dirname(), 'scans')

    def getVulnerabilityDir(self):
        return os.path.join(self.dirname(), 'vulns')

    def sanitizeVulnerabilityPath(self, path):
        return os.path.join(self.getVulnerabilityDir(), os.path.basename(path))

    def loadVulnerabilities(self):
        self.vulns = []
        if os.path.isdir(self.getVulnerabilityDir()):
            for vulndir in QtPtObjects.QVulnerability.enum(self.getVulnerabilityDir()):
                self.vulns.append(QtPtObjects.QVulnerability(folder=self.sanitizeVulnerabilityPath(vulndir)).read())
        return self.vulns

    def addTarget(self, *args, **kwargs):
        newTarget = QtPtObjects.QTarget.build(*args, **kwargs)
        if not newTarget.isEmpty():
            self.targets.append(newTarget)
            return newTarget
        return None

    def delTarget(self, *args, **kwargs):
        wantedTarget = QtPtObjects.QTarget.build(*args, **kwargs)
        for index, target in enumerate(self.targets):
            if str(target) == str(wantedTarget):
                del self.targets[index]
        return self

    def addAccount(self, *args, **kwargs):
        newAccount = QtPtObjects.QAccount.build(*args, **kwargs)
        if not newAccount.isEmpty():
            self.accounts.append(newAccount)
            return newAccount
        return None

    def delAccount(self, *args, **kwargs):
        wantedAccount = QtPtObjects.QAccount.build(*args, **kwargs)
        for index, account in enumerate(self.accounts):
            if str(account) == str(wantedAccount):
                del self.accounts[index]
        return self

    def getShellLogDir(self):
        return QtCore.QDir('{}/shell-logs'.format(self.dirname())).absolutePath()

    def newShellLogFilename(self):
        filename = 'Shell_{}.txt'.format(QtCore.QDateTime.currentMSecsSinceEpoch())
        return QtCore.QDir(self.getShellLogDir()).absoluteFilePath(filename)

    def getScreenshotsDir(self):
        """ Get the screenshots folder for the current project

        Return:
        the absolute path of the screenshots folder
        """
        return os.path.join(self.dirname(), 'screenshots')

    def sanitizeScreenshotPath(self, path):
        """ Sanitize a screenshot path to make sure it is in the appropriate folder

        Return:
        the sanitized path
        """
        return os.path.join(self.getScreenshotsDir(), os.path.basename(path))

    def countScreenshots(self):
        """ Count the number of screenshots taken

        Return:
        the number of PNG file in the screenshots folder
        """
        if os.path.isdir(self.getScreenshotsDir()):
            return len([os.path.basename(f) for f in glob.glob(os.path.join(self.getScreenshotsDir(), '*.png'))])
        return 0

    def takeScreenshot(self):
        """ Take a screenshot
        The used software is `scrot` and need to be installed
        """
        picture = None
        if not os.path.isdir(self.getScreenshotsDir()):
            os.makedirs(self.getScreenshotsDir(), exist_ok=True)
        if os.path.isfile('/usr/bin/scrot'):
            command = [
                '/usr/bin/scrot', 
                'Screenshot_%Y%m%d_%H%M%S.png', 
                '-e', 'mv $f {}; echo $f'.format(self.getScreenshotsDir())
            ]
            with subprocess.Popen(command, stdout=subprocess.PIPE) as process:
                picture = process.stdout.read().decode('utf-8').strip('\n')
                picture = os.path.join(self.getScreenshotsDir(), picture)
        return picture

    @staticmethod
    def sanitizeProjectFolder(string):
        """ Sanitize string to use it as directory or file name
        - Replace spaces with underscores
        - Remove non-word characters (keep A-Z, a-z, 0-9 and _)
        - Check for any multiples underscores
        - Remove underscores at the beginning and the end of the string

        Keyword arguments:
        string -- the input string

        Return:
        the sanitized string
        """
        return re.sub(r'__+', '_', re.sub(r'[^A-Za-z0-9_]+', '', string.replace(' ', '_'))).strip('_')
        
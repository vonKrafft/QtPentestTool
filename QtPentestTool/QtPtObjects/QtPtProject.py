# Copyright (c) 2019 vonKrafft <contact@vonkrafft.fr>
# 
# This file is part of QtPentestTool.
# 
# This file may be used under the terms of the GNU General Public License
# version 3.0 as published by the Free Software Foundation and appearing in
# the file LICENSE included in the packaging of this file. Please review the
# following information to ensure the GNU General Public License version 3.0
# requirements will be met: http://www.gnu.org/copyleft/gpl.html.
# 
# This file is provided AS IS with NO WARRANTY OF ANY KIND, INCLUDING THE
# WARRANTY OF DESIGN, MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.

from PyQt5 import QtCore

from .. import QtPtObjects

import glob
import json
import os
import re # PyQt5.QtCore.QRegExp has no replace method, thus "re" is needed
import shutil
import subprocess


class QProject(object):
    """ Model object for a project.

    Attributes:
        database (str): The file to store project's information
        data ({str: object}): Data stored in the JSON file
        targets ([QtPtObjects.QTarget]): The list of project's targets
        accounts ([QtPtObjects.QAccount]): The list of project's accounts
        vulns ([QtPtObjects.QVulnerability]): The list of project's vulnerabilities

    Constants:
        DATA_DEFAULT ({str: object}): Default data to store in the JSON file

    """

    DATA_DEFAULT = { 'name': 'Unknown client', 'client': 'Untitled', 'date': '1970-01-01', 'cvss_version': 3, 'accounts': [], 'targets': [] }

    def __init__(self, folder: str, database: str = 'project.json') -> None:
        """ Class constructor.

        Args:
            folder (str): The folder in which to save information and project's resources
            database (str): The file to store project's information (default 'project.json')

        """
        self.database = os.path.join(os.path.abspath(folder), os.path.basename(database))
        self.data = self.DATA_DEFAULT
        self.targets, self.accounts, self.vulns = [], [], []

    def read(self) -> 'QProject':
        """ Retrieve project's information from the database file.
        The file has to exist and be JSON.

        Returns:
            QProject: The current class

        """
        if os.path.isfile(self.database):
            with open(self.database, 'r') as file:
                self.data = { **self.DATA_DEFAULT, **json.load(file) }
            for target in self.data['targets']:
                if 'hostname' in target:
                    self.targets.append(QtPtObjects.QTarget(**target))
            for account in self.data['accounts']:
                if 'username' in account:
                    self.accounts.append(QtPtObjects.QAccount(**account))
            self.loadVulnerabilities()
        return self

    def write(self) -> 'QProject':
        """ Save project's information into the database file.
        The data will be stored in JSON and the file will be overwritten.

        Returns:
            QProject: The current class

        """
        self.data['targets'] = [target.dict() for target in self.targets]
        self.data['accounts'] = [account.dict() for account in self.accounts]
        with open(self.database, 'w') as file:
            json.dump(self.data, file, indent=4)
        return self

    def create(self, workdir: str = '/tmp', database: str = 'project.json') -> bool:
        """ Create a new project.

        Args:
            folder (str): The folder in which to create project's folder (default '/tmp')
            database (str): The file to store project's information (default 'project.json')

        Returns:
            bool: True if the project was created, False otherwise

        """
        folder = '{date}-{client}-{name}'.format(
            date=re.sub(r'[^0-9]+', '', self.get('date', self.DATA_DEFAULT.get('date'))),
            client=QProject.sanitizeProjectFolder(self.get('client', self.DATA_DEFAULT.get('client'))),
            name=QProject.sanitizeProjectFolder(self.get('name', self.DATA_DEFAULT.get('name')))
        ).upper()
        self.database = os.path.join(os.path.abspath(workdir), folder, os.path.basename(database))
        if not os.path.isdir(self.dirname()):
            os.makedirs(self.dirname(), exist_ok=True)
            os.makedirs(os.path.join(self.dirname(), 'burp'), exist_ok=True)
            os.makedirs(os.path.join(self.dirname(), 'downloads'), exist_ok=True)
            os.makedirs(os.path.join(self.dirname(), 'scans'), exist_ok=True)
            os.makedirs(os.path.join(self.dirname(), 'screenshots'), exist_ok=True)
            os.makedirs(os.path.join(self.dirname(), 'shell-logs'), exist_ok=True)
            os.makedirs(os.path.join(self.dirname(), 'vulns'), exist_ok=True)
            self.write()
            return True
        return False

    def export(self, formatArchive: str = 'tar') -> str:
        """ Create an archive file (such as zip or tar).

        Args:
            formatArchive (str): The archive format (default 'tar')

        Returns:
            str: The archive's name

        """
        if formatArchive in [f[0] for f in shutil.get_archive_formats()]:
            return shutil.make_archive(self.dirname(), formatArchive, os.path.dirname(self.dirname()), self.basename())
        return None

    def get(self, key: str, default: object = None) -> object:
        """ Getter for a project property.

        Args:
            key (str): The name of the property
            default (object): The default value if the property does not exist (default None)

        Returns:
            object: The value of the requested property
        """
        return self.data.get(key, default)

    def set(self, key: str, value: object) -> None:
        """ Setter for a project property.

        Args:
            key (str): The name of the property
            value (object): The value of the property

        """
        self.data[key] = value

    def basename(self) -> str:
        """ Get the basename of the project's database
    
        Returns:
            str: The base name of the project's database

        """
        return os.path.basename(self.dirname())

    def dirname(self) -> str:
        """ Get the directory name of the project's database.
    
        Returns:
            str: The directory name of the project's database

        """
        return os.path.dirname(os.path.abspath(self.database))

    def relpath(self, filepath: str) -> str:
        """ Get the relative path of the given filepath from the directory of the project's database.

        Args:
            filepath (str): The filepath of which the relative path is wanted
    
        Returns:
            str: The relative path of the given filepath from the directory of the project's database

        """
        return os.path.relpath(filepath, self.dirname())

    @staticmethod
    def enum(root: str, database: str = 'project.json') -> [str]:
        """ List all the directories in `root` that have the `database` file.

        Args:
            root (str): The folder in which to search for projects
            database (str, optional): The name of the database file that defines a project as such (default 'project.json')

        Returns:
            [str]: An array of the found projects

        """
        root = os.path.abspath(root)
        if os.path.isdir(root):
            return [os.path.dirname(f) for f in glob.glob(os.path.join(root, '*', database))]
        return []

    @staticmethod
    def isProject(folder: str, database: str = 'project.json') -> bool:
        """ Check if the given folder is a valid project database.

        Args:
            folder (str): The project's folder whose validity must be checked
            database (str): The name of the database file that defines a project as such (default 'project.json')

        Returns:
            bool: True if the given folder contains the 'database' file, False otherwise

        """
        if os.path.isfile(os.path.join(os.path.abspath(folder), os.path.basename(database))):
            try:
                with open(os.path.join(os.path.abspath(folder), os.path.basename(database)), 'r') as file:
                    data = json.load(file)
                return all(key in data for key in ( 'name', 'client', 'date', 'accounts', 'targets' ))
            except json.JSONDecodeError:
                return False
        return False

    def getBurpDir(self) -> str:
        """ Get the directory in which the burp are stored.

        Returns:
            str: The burp directory

        """
        return QtCore.QDir(f'{self.dirname()}/burp').absolutePath()

    def sanitizeBurpPath(self, filepath: str) -> str:
        """ Sanitize a burp filepath to make sure it is in the appropriate folder.

        Args:
            filepath (str): The filepath to sanitize

        Returns:
            str: The sanitized path

        """
        return os.path.join(self.getBurpDir(), os.path.basename(filepath))

    def getDownloadsDir(self) -> str:
        """ Get the directory in which the downloads are stored.

        Returns:
            str: The downloads directory

        """
        return QtCore.QDir(f'{self.dirname()}/downloads').absolutePath()

    def sanitizeDownloadPath(self, filepath: str) -> str:
        """ Sanitize a download filepath to make sure it is in the appropriate folder.

        Args:
            filepath (str): The filepath to sanitize

        Returns:
            str: The sanitized path

        """
        return os.path.join(self.getDownloadsDir(), os.path.basename(filepath))

    def getScansDir(self) -> str:
        """ Get the directory in which the scans are stored.

        Returns:
            str: The scans directory

        """
        return QtCore.QDir(f'{self.dirname()}/scans').absolutePath()

    def sanitizeScanPath(self, filepath: str) -> str:
        """ Sanitize a scan filepath to make sure it is in the appropriate folder.

        Args:
            filepath (str): The filepath to sanitize

        Returns:
            str: The sanitized path

        """
        return os.path.join(self.getScansDir(), os.path.basename(filepath))

    def getScreenshotsDir(self) -> str:
        """ Get the directory in which the scans are stored.

        Returns:
            str: The scans directory

        """
        return QtCore.QDir(f'{self.dirname()}/screenshots').absolutePath()

    def sanitizeScreenshotPath(self, filepath: str) -> str:
        """ Sanitize a screenshot filepath to make sure it is in the appropriate folder.

        Args:
            filepath (str): The filepath to sanitize

        Returns:
            str: The sanitized path

        """
        return os.path.join(self.getScreenshotsDir(), os.path.basename(filepath))

    def getShellLogsDir(self) -> str:
        """ Get the directory in which the shell logs are stored.

        Returns:
            str: The shell logs directory

        """
        return QtCore.QDir(f'{self.dirname()}/shell-logs').absolutePath()

    def sanitizeShellLogsPath(self, filepath: str) -> str:
        """ Sanitize a shell log filepath to make sure it is in the appropriate folder.

        Args:
            filepath (str): The filepath to sanitize

        Returns:
            str: The sanitized path

        """
        return os.path.join(self.getShellLogsDir(), os.path.basename(filepath))

    def getVulnerabilitiesDir(self) -> str:
        """ Get the directory in which the vulnerabilities are stored.

        Returns:
            str: The vulnerabilities directory

        """
        return QtCore.QDir(f'{self.dirname()}/vulns').absolutePath()

    def sanitizeVulnerabilityPath(self, filepath: str) -> str:
        """ Sanitize a vulnerability filepath to make sure it is in the appropriate folder.

        Args:
            filepath (str): The filepath to sanitize

        Returns:
            str: The sanitized path

        """
        return os.path.join(self.getVulnerabilitiesDir(), os.path.basename(filepath))

    def loadVulnerabilities(self) -> ['QtPtObjects.QVulnerability']:
        """ Browse the vulnerabilities directory to list project's vulnerabilities.

        Returns:
            [QtPtObjects.QVulnerability]: The vulnerabilities list

        """
        self.vulns = []
        if os.path.isdir(self.getVulnerabilitiesDir()):
            for vulndir in QtPtObjects.QVulnerability.enum(self.getVulnerabilitiesDir()):
                self.vulns.append(QtPtObjects.QVulnerability(folder=self.sanitizeVulnerabilityPath(vulndir)).read())
        return self.vulns

    def addTarget(self, *args, **kwargs) -> 'QtPtObjects.QTarget':
        """ Add a new target to the current project.

        Args:
            *args: Variable length argument list
            **kwargs: Arbitrary keyword arguments

        Returns:
            QtPtObjects.QTarget: The added target, None if error occurs

        """
        newTarget = QtPtObjects.QTarget(*args, **kwargs)
        if not newTarget.isEmpty():
            self.targets.append(newTarget)
            return newTarget
        return None

    def delTarget(self, *args, **kwargs) -> 'QProject':
        """ Delete an existing target from the current project.

        Args:
            *args: Variable length argument list
            **kwargs: Arbitrary keyword arguments

        Returns:
            QProject: The current class

        """
        wantedTarget = QtPtObjects.QTarget(*args, **kwargs)
        for index, target in enumerate(self.targets):
            if str(target) == str(wantedTarget):
                del self.targets[index]
        return self

    def addAccount(self, *args, **kwargs) -> 'QtPtObjects.QAccount':
        """ Add a new account to the current project.

        Args:
            *args: Variable length argument list
            **kwargs: Arbitrary keyword arguments

        Returns:
            QtPtObjects.QAccount: The added account, None if error occurs

        """
        newAccount = QtPtObjects.QAccount(*args, **kwargs)
        if not newAccount.isEmpty():
            self.accounts.append(newAccount)
            return newAccount
        return None

    def delAccount(self, *args, **kwargs) -> 'QProject':
        """ Delete an existing account from the current project.

        Args:
            *args: Variable length argument list
            **kwargs: Arbitrary keyword arguments

        Returns:
            QProject: The current class

        """
        wantedAccount = QtPtObjects.QAccount(*args, **kwargs)
        for index, account in enumerate(self.accounts):
            if str(account) == str(wantedAccount):
                del self.accounts[index]
        return self

    def newShellLogFilename(self) -> str:
        """ Create a new filename to store shell logs

        Returns:
            str: A filename based on current timestamps

        """
        filename = f'Shell_{QtCore.QDateTime.currentMSecsSinceEpoch()}.txt'
        return QtCore.QDir(self.getShellLogsDir()).absoluteFilePath(filename)

    def countScreenshots(self) -> int:
        """ Count the number of screenshots taken

        Returns:
            int: The number of PNG file in the screenshots folder

        """
        if os.path.isdir(self.getScreenshotsDir()):
            return len([os.path.basename(f) for f in glob.glob(os.path.join(self.getScreenshotsDir(), '*.png'))])
        return 0

    def takeScreenshot(self) -> str:
        """ Take a screenshot.
        The used software is `scrot` and need to be installed.

        Returns:
            str: The filename of the taken screenshot

        """
        picture = None
        if not os.path.isdir(self.getScreenshotsDir()):
            os.makedirs(self.getScreenshotsDir(), exist_ok=True)
        if os.path.isfile('/usr/bin/scrot'):
            command = [
                '/usr/bin/scrot', 
                'Screenshot_%Y%m%d_%H%M%S.png', 
                '-e', f'mv "$f" "{self.getScreenshotsDir()}"; echo "$f"'
            ]
            with subprocess.Popen(command, stdout=subprocess.PIPE) as process:
                picture = process.stdout.read().decode('utf-8').strip('\n')
                picture = os.path.join(self.getScreenshotsDir(), picture)
        return picture

    @staticmethod
    def sanitizeProjectFolder(text: str) -> str:
        """ Sanitize string to use it as directory or file name:
        - Replace spaces with underscores
        - Remove non-word characters (keep A-Z, a-z, 0-9 and _)
        - Check for any multiples underscores
        - Remove underscores at the beginning and the end of the string

        Args:
            text (str): The input string

        Returns:
            str: The sanitized directory name

        """
        return re.sub(r'__+', '_', re.sub(r'[^A-Za-z0-9_]+', '', text.replace(' ', '_'))).strip('_')
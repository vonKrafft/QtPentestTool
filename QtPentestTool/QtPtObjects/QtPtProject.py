# Copyright (c) 2019 vonKrafft <contact@vonkrafft.fr>
# 
# This file is part of QtPentestTool.
# 
# This file may be used under the terms of the GNU General Public License
# version 3.0 as published by the Free Software Foundation and appearing in
# the file LICENSE included in the packaging of this file. Please review the
# following information to ensure the GNU General Public License version 3.0
# requirements will be met: http://www.gnu.org/copyleft/gpl.html.
# 
# This file is provided AS IS with NO WARRANTY OF ANY KIND, INCLUDING THE
# WARRANTY OF DESIGN, MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.

from PyQt5 import QtCore

from .. import QtPtObjects

import json
import re # PyQt5.QtCore.QRegExp has no replace method, thus "re" is needed
import shutil
import subprocess


class QProject(QtCore.QDir):
    """ Model object for a project.

    Attributes:
        _database (QtCore.QFileInfo): The file to store project's information
        _data ({str: object}): Data stored in the JSON file
        _targets ([QtPtObjects.QTarget]): The list of project's targets
        _accounts ([QtPtObjects.QAccount]): The list of project's accounts
        _vulns ([QtPtObjects.QVulnerability]): The list of project's vulnerabilities

    Constants:
        DATA_DEFAULT ({str: object}): Default data to store in the JSON file

    """

    """ The file to store project's information """
    _database = None

    """ Default data to store in the JSON file """
    DATA_DEFAULT = { 'name': 'Unknown client', 'client': 'Untitled', 'date': '1970-01-01', 'cvss_version': 3, 'accounts': [], 'targets': [] }

    def __init__(self, folder: str, database: str = 'project.json', *args, **kwargs) -> None:
        """ Class constructor.

        Args:
            folder (str): The folder in which to save information and project's resources
            database (str): The file to store project's information (default 'project.json')
            *args: Variable length argument list
            **kwargs: Arbitrary keyword arguments

        """
        super(QProject, self).__init__(*args, **kwargs)

        self.setPath(QtCore.QDir.tempPath() if folder is None else folder)
        self.setDatabase(database)

        self._data = self.DATA_DEFAULT
        self._targets, self._accounts, self._vulns = [], [], []

    def setDatabase(self, file: object) -> None:
        """ Setter for the project's database

        Args:
            file (str | QtCore.QFileInfo): The database object to set

        """
        if not isinstance(file, QtCore.QFileInfo):
            file = self.absoluteFilePath(QtCore.QFileInfo(str(file)).fileName())
        self._database = QtCore.QFileInfo(file)

    def database(self) -> 'QtCore.QFileInfo':
        """ Getter for the project's database object

        Returns:
            QtCore.QFileInfo: The current database object

        """
        return self._database;

    def databasePath(self) -> str:
        """ Getter for the project's database path

        Returns:
            str: The current database path

        """
        return self._database.absoluteFilePath()

    def __hash__(self) -> int:
        """ Defines behavior for when hash() is called on an instance of this class.

        Returns:
            int: The hash of the project's database path

        """
        return hash(self.databasePath())

    def __eq__(self, other: 'QProject') -> bool:
        """ Defines behavior for the equality operator (==).

        Args:
            other (QProject): The object to compare with

        Returns:
            bool: True if the current is equal to other, False otherwise

        """
        return hash(self) == hash(other)

    def __ne__(self, other: 'QProject') -> bool:
        """ Defines behavior for the inequality operator (!=).

        Args:
            other (QProject): The object to compare with

        Returns:
            bool: False if the current is equal to other, True otherwise

        """
        return hash(self) != hash(other)

    def __str__(self) -> str:
        """ String representation for the class.

        Returns:
            str: The current class as a string

        """
        return f'{self.get("client", "Nobody")} - {self.get("name", "Untitled project")}'

    def read(self) -> 'QProject':
        """ Retrieve project's information from the database file.
        The file has to exist and be JSON.

        Returns:
            QProject: The current class

        """
        with open(self.databasePath(), 'r') as file:
            self._data = { **self.DATA_DEFAULT, **json.load(file) }

        for target in self._data['targets']:
            if 'hostname' in target:
                self._targets.append(QtPtObjects.QTarget(**target))
        for account in self._data['accounts']:
            if 'username' in account:
                self._accounts.append(QtPtObjects.QAccount(**account))
        self.loadVulnerabilities()

        return self

    def write(self) -> 'QProject':
        """ Save project's information into the database file.
        The data will be stored in JSON and the file will be overwritten.

        Returns:
            QProject: The current class

        """
        self._data['targets'] = [target.dict() for target in self._targets]
        self._data['accounts'] = [account.dict() for account in self._accounts]
        with open(self.databasePath(), 'w') as file:
            json.dump(self._data, file, indent=4)
        return self

    def create(self, parentPath: str = None, suffix: str = '', database: str = 'project.json') -> bool:
        """ Create a new project.

        Args:
            parentPath (str): The folder in which to create project's folder (default None)
            suffix (str, optional): A suffix for the project's name
            database (str, optional): The file to store project's information (default 'project.json')

        Returns:
            bool: True if the project was created, False otherwise

        """
        parentDir = QtCore.QDir.temp() if parentPath is None else QtCore.QDir(parentPath)
        projectDest = QtCore.QFileInfo(parentDir, '{date}-{client}-{name}{suffix}'.format(
            date=re.sub(r'[^0-9]+', '', self.get('date', self.DATA_DEFAULT.get('date'))),
            client=QProject.sanitizeProjectFolder(self.get('client', self.DATA_DEFAULT.get('client'))),
            name=QProject.sanitizeProjectFolder(self.get('name', self.DATA_DEFAULT.get('name'))),
            suffix=f'-{suffix}' if len(suffix) > 0 else  ''
        ).upper())

        if not projectDest.isDir():
            projectDest.dir().mkdir(projectDest.fileName())
            self.setPath(projectDest.absoluteFilePath())
            self.setDatabase(database)
            self.mkdir('burp')
            self.mkdir('downloads')
            self.mkdir('scans')
            self.mkdir('screenshots')
            self.mkdir('shell-logs')
            self.mkdir('vulns')
            self.write()
            return True

        return False

    def export(self, formatArchive: str = 'tar') -> str:
        """ Create an archive file (such as zip or tar).

        Args:
            formatArchive (str): The archive format (default 'tar')

        Returns:
            str: The archive's name

        """
        if formatArchive in [f[0] for f in shutil.get_archive_formats()]:
            return shutil.make_archive(self.absolutePath(), formatArchive, self.parentPath(), self.dirName())
        return None

    def get(self, key: str, default: object = None) -> object:
        """ Getter for a project property.

        Args:
            key (str): The name of the property
            default (object): The default value if the property does not exist (default None)

        Returns:
            object: The value of the requested property
        """
        return self._data.get(key, default)

    def set(self, key: str, value: object) -> None:
        """ Setter for a project property.

        Args:
            key (str): The name of the property
            value (object): The value of the property

        """
        self._data[key] = value

    def parentDir(self) -> 'QtCore.QDir' :
        """ Get the parent directory

        Returns:
            QtCore.QDir: The parent directory

        """
        currentDir = QtCore.QDir(self.absolutePath())
        currentDir.cdUp()
        return currentDir

    def parentPath(self) -> str :
        """ Get the parent directory absolute path

        Returns:
            str: The parent directory absolute path

        """
        return self.parentDir().absolutePath()

    @staticmethod
    def enum(root: str, database: str = 'project.json') -> [str]:
        """ List all the directories in `root` that have the `database` file.

        Args:
            root (str): The folder in which to search for projects
            database (str, optional): The name of the database file that defines a project as such (default 'project.json')

        Returns:
            [str]: An array of the found projects

        """
        root = QtCore.QDir(root)
        if root.exists():
            dirList = root.entryInfoList(QtCore.QDir.Dirs | QtCore.QDir.NoDotAndDotDot)
            return [d.absoluteFilePath() for d in dirList if QtCore.QDir(d.absoluteFilePath()).exists(database)]
        return []

    @staticmethod
    def isProject(folder: str, database: str = 'project.json') -> bool:
        """ Check if the given folder is a valid project database.

        Args:
            folder (str): The project's folder whose validity must be checked
            database (str): The name of the database file that defines a project as such (default 'project.json')

        Returns:
            bool: True if the given folder contains the 'database' file, False otherwise

        """
        folder = QtCore.QDir.temp() if folder is None else QtCore.QDir(folder)
        if folder.exists(database):
            try:
                with open(folder.absoluteFilePath(database), 'r') as file:
                    data = json.load(file)
                return all(key in data for key in ( 'name', 'client', 'date', 'accounts', 'targets' ))
            except json.JSONDecodeError:
                return False
        return False

    def burpPath(self) -> str:
        """ Get the directory in which the burp are stored.

        Returns:
            str: The burp directory

        """
        return self.absoluteFilePath('burp')

    def sanitizeBurpPath(self, filepath: str) -> str:
        """ Sanitize a burp filepath to make sure it is in the appropriate folder.

        Args:
            filepath (str): The filepath to sanitize

        Returns:
            str: The sanitized path

        """
        filepath = QtCore.QDir(filepath).dirName()
        return QtCore.QDir(self.burpPath()).absoluteFilePath(filepath)

    def downloadsPath(self) -> str:
        """ Get the directory in which the downloads are stored.

        Returns:
            str: The downloads directory

        """
        return self.absoluteFilePath('downloads')

    def sanitizeDownloadPath(self, filepath: str) -> str:
        """ Sanitize a download filepath to make sure it is in the appropriate folder.

        Args:
            filepath (str): The filepath to sanitize

        Returns:
            str: The sanitized path

        """
        filepath = QtCore.QDir(filepath).dirName()
        return QtCore.QDir(self.downloadsPath()).absoluteFilePath(filepath)

    def scansPath(self) -> str:
        """ Get the directory in which the scans are stored.

        Returns:
            str: The scans directory

        """
        return self.absoluteFilePath('scans')

    def sanitizeScanPath(self, filepath: str) -> str:
        """ Sanitize a scan filepath to make sure it is in the appropriate folder.

        Args:
            filepath (str): The filepath to sanitize

        Returns:
            str: The sanitized path

        """
        filepath = QtCore.QDir(filepath).dirName()
        return QtCore.QDir(self.scansPath()).absoluteFilePath(filepath)

    def screenshotsPath(self) -> str:
        """ Get the directory in which the scans are stored.

        Returns:
            str: The scans directory

        """
        return self.absoluteFilePath('screenshots')

    def sanitizeScreenshotPath(self, filepath: str) -> str:
        """ Sanitize a screenshot filepath to make sure it is in the appropriate folder.

        Args:
            filepath (str): The filepath to sanitize

        Returns:
            str: The sanitized path

        """
        filepath = QtCore.QDir(filepath).dirName()
        return QtCore.QDir(self.screenshotsPath()).absoluteFilePath(filepath)

    def shellLogsDir(self) -> str:
        """ Get the directory in which the shell logs are stored.

        Returns:
            str: The shell logs directory

        """
        return self.absoluteFilePath('shell-logs')

    def sanitizeShellLogsPath(self, filepath: str) -> str:
        """ Sanitize a shell log filepath to make sure it is in the appropriate folder.

        Args:
            filepath (str): The filepath to sanitize

        Returns:
            str: The sanitized path

        """
        filepath = QtCore.QDir(filepath).dirName()
        return QtCore.QDir(self.shellLogsDir()).absoluteFilePath(filepath)

    def vulnsPath(self) -> str:
        """ Get the directory in which the vulnerabilities are stored.

        Returns:
            str: The vulnerabilities directory

        """
        return self.absoluteFilePath('vulns')

    def sanitizeVulnerabilityPath(self, filepath: str) -> str:
        """ Sanitize a vulnerability filepath to make sure it is in the appropriate folder.

        Args:
            filepath (str): The filepath to sanitize

        Returns:
            str: The sanitized path

        """
        filepath = QtCore.QDir(filepath).dirName()
        return QtCore.QDir(self.vulnsPath()).absoluteFilePath(filepath)

    def vulnerabilities(self) -> ['QtPtObjects.QVulnerability']:
        """ Getter for the current project's vulnerabilities.

        Returns:
            [QtPtObjects.QVulnerability]: The vulnerabilities list

        """
        return self._vulns

    def loadVulnerabilities(self) -> ['QtPtObjects.QVulnerability']:
        """ Browse the vulnerabilities directory to list project's vulnerabilities.

        Returns:
            [QtPtObjects.QVulnerability]: The vulnerabilities list

        """
        self._vulns = []
        if QtCore.QFileInfo(self.vulnsPath()).isDir():
            for vulndir in QtPtObjects.QVulnerability.enum(self.vulnsPath()):
                self._vulns.append(QtPtObjects.QVulnerability(folder=self.sanitizeVulnerabilityPath(vulndir)).read())
        return self._vulns

    def targets(self) -> ['QtPtObjects.QTarget']:
        """ Getter for the current project's targets.

        Returns:
            [QtPtObjects.QTarget]: The targets list

        """
        return self._targets

    def addTarget(self, *args, **kwargs) -> 'QtPtObjects.QTarget':
        """ Add a new target to the current project.

        Args:
            *args: Variable length argument list
            **kwargs: Arbitrary keyword arguments

        Returns:
            QtPtObjects.QTarget: The added target, None if error occurs

        """
        newTarget = QtPtObjects.QTarget(*args, **kwargs)
        if not newTarget.isEmpty():
            self._targets.append(newTarget)
            return newTarget
        return None

    def delTarget(self, *args, **kwargs) -> 'QProject':
        """ Delete an existing target from the current project.

        Args:
            *args: Variable length argument list
            **kwargs: Arbitrary keyword arguments

        Returns:
            QProject: The current class

        """
        wantedTarget = QtPtObjects.QTarget(*args, **kwargs)
        for index, target in enumerate(self._targets):
            if str(target) == str(wantedTarget):
                del self._targets[index]
        return self

    def accounts(self) -> ['QtPtObjects.QAccount']:
        """ Getter for the current project's accounts.

        Returns:
            [QtPtObjects.QAccount]: The accounts list

        """
        return self._accounts

    def addAccount(self, *args, **kwargs) -> 'QtPtObjects.QAccount':
        """ Add a new account to the current project.

        Args:
            *args: Variable length argument list
            **kwargs: Arbitrary keyword arguments

        Returns:
            QtPtObjects.QAccount: The added account, None if error occurs

        """
        newAccount = QtPtObjects.QAccount(*args, **kwargs)
        if not newAccount.isEmpty():
            self._accounts.append(newAccount)
            return newAccount
        return None

    def delAccount(self, *args, **kwargs) -> 'QProject':
        """ Delete an existing account from the current project.

        Args:
            *args: Variable length argument list
            **kwargs: Arbitrary keyword arguments

        Returns:
            QProject: The current class

        """
        wantedAccount = QtPtObjects.QAccount(*args, **kwargs)
        for index, account in enumerate(self._accounts):
            if str(account) == str(wantedAccount):
                del self._accounts[index]
        return self

    def newShellLogFilename(self) -> str:
        """ Create a new filename to store shell logs

        Returns:
            str: A filename based on current timestamps

        """
        filename = f'Shell_{QtCore.QDateTime.currentMSecsSinceEpoch()}.txt'
        return QtCore.QDir(self.shellLogsDir()).absoluteFilePath(filename)

    def listScreenshots(self) -> [str]:
        """ Get taken screenshots list.

        Returns:
            [str]: The list of PNG file in the screenshots folder

        """
        if QtCore.QFileInfo(self.screenshotsPath()).isDir():
            return QtCore.QDir(self.screenshotsPath()).entryList(['*.png'])
        return []

    def countScreenshots(self) -> int:
        """ Count the number of screenshots taken

        Returns:
            int: The number of PNG file in the screenshots folder

        """
        return len(self.listScreenshots())

    def takeScreenshot(self) -> str:
        """ Take a screenshot.
        The used software is `scrot` and need to be installed.

        Returns:
            str: The filename of the taken screenshot

        """
        picture = None
        if not QtCore.QFileInfo(self.screenshotsPath()).isDir():
            self.mkdir('screenshots')
        if QtCore.QFileInfo('/usr/bin/scrot').isExecutable():
            command = [
                '/usr/bin/scrot', 
                'Screenshot_%Y%m%d_%H%M%S.png', 
                '-e', f'mv "$f" "{self.screenshotsPath()}"; echo "$f"'
            ]
            with subprocess.Popen(command, stdout=subprocess.PIPE) as process:
                picture = process.stdout.read().decode('utf-8').strip('\n')
                picture = QtCore.QDir(self.screenshotsPath()).absoluteFilePath(picture)
        return picture

    @staticmethod
    def sanitizeProjectFolder(text: str) -> str:
        """ Sanitize string to use it as directory or file name:
        - Replace spaces with underscores
        - Remove non-word characters (keep A-Z, a-z, 0-9 and _)
        - Check for any multiples underscores
        - Remove underscores at the beginning and the end of the string

        Args:
            text (str): The input string

        Returns:
            str: The sanitized directory name

        """
        return re.sub(r'__+', '_', re.sub(r'[^A-Za-z0-9_]+', '', text.replace(' ', '_'))).strip('_')
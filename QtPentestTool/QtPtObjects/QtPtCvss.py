# Copyright (c) 2019 vonKrafft <contact@vonkrafft.fr>
# 
# This file is part of QtPentestTool.
# 
# This file may be used under the terms of the GNU General Public License
# version 3.0 as published by the Free Software Foundation and appearing in
# the file LICENSE included in the packaging of this file. Please review the
# following information to ensure the GNU General Public License version 3.0
# requirements will be met: http://www.gnu.org/copyleft/gpl.html.
# 
# This file is provided AS IS with NO WARRANTY OF ANY KIND, INCLUDING THE
# WARRANTY OF DESIGN, MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.

from PyQt5 import QtCore

from .. import QtPtCore
from .. import QtPtObjects

import json
import math


class QCvss(QtCore.QFileInfo):
    """ Model object for a CVSS score.

    Attributes:
        _version (int): The CVSS version to use, either 2 or 3
        _data ({str: object}): Data stored in the JSON file

        AttackVector (QtPtObjects.QMetric): The 'Attack Vector' metric
        AttackComplexity (QtPtObjects.QMetric): The 'Attack Complexity' metric
        Authentication (QtPtObjects.QMetric): The 'Authentication' metric
        PrivilegesRequired (QtPtObjects.QMetric): The 'Privileges Required' metric
        UserInteraction (QtPtObjects.QMetric): The 'User Interaction' metric
        Scope (QtPtObjects.QMetric): The 'Scope' metric
        Confidentiality (QtPtObjects.QMetric): The 'Confidentiality' metric
        Integrity (QtPtObjects.QMetric): The 'Integrity' metric
        Availability (QtPtObjects.QMetric): The 'Availability' metric

    """

    def __init__(self, folder: str = None, database: str = 'cvss.json', version: int = 3, *args, **kwargs) -> None:
        """ Class constructor.

        Args:
            folder (str): The folder in which to save the database file (default None)
            database (str): The file to store CVSS metrics (default 'cvss.json')
            version (int): The CVSS version to use (default 3)
            *args: Variable length argument list
            **kwargs: Arbitrary keyword arguments

        """
        super(QCvss, self).__init__(*args, **kwargs)

        self.setFile(QtCore.QDir.temp() if folder is None else QtCore.QDir(folder), database)

        self._version = max(2, min(3, int(version)))
        self._data = { 'version': self._version, 'score': 0.0, 'metrics': dict() }

        self.AttackVector = QtPtObjects.QMetric()
        self.AttackComplexity = QtPtObjects.QMetric()
        self.Authentication = QtPtObjects.QMetric()
        self.PrivilegesRequired = QtPtObjects.QMetric()
        self.UserInteraction = QtPtObjects.QMetric()
        self.Scope = QtPtObjects.QMetric()
        self.Confidentiality = QtPtObjects.QMetric()
        self.Integrity = QtPtObjects.QMetric()
        self.Availability = QtPtObjects.QMetric()

    def read(self) -> 'QCvss':
        """ Retrieve CVSS metrics from the database file.
        The file has to exist and be JSON.

        Returns:
            QCvss: The current class

        """
        with open(self.absoluteFilePath(), 'r') as file:
            self._data = json.load(file)

        self.setVersion(self._data.get('version', 3))

        if self.version() == 2:
            self.AttackVector = QtPtObjects.QMetric(QtPtCore.QtPt.AttackVectorMetric, 'Access Vector', 2)
            self.AttackComplexity = QtPtObjects.QMetric(QtPtCore.QtPt.AttackComplexityMetric, 'Access Complexity', 2)
            self.Authentication = QtPtObjects.QMetric(QtPtCore.QtPt.AuthenticationMetric, 'Authentication', 2)
            self.Confidentiality = QtPtObjects.QMetric(QtPtCore.QtPt.ConfidentialityMetric, 'Confidentiality', 2)
            self.Integrity = QtPtObjects.QMetric(QtPtCore.QtPt.IntegrityMetric, 'Integrity', 2)
            self.Availability = QtPtObjects.QMetric(QtPtCore.QtPt.AvailabilityMetric, 'Availability', 2)
        elif self.version() == 3:
            self.AttackVector = QtPtObjects.QMetric(QtPtCore.QtPt.AttackVectorMetric, 'Attack Vector', 3)
            self.AttackComplexity = QtPtObjects.QMetric(QtPtCore.QtPt.AttackComplexityMetric, 'Attack Complexity', 3)
            self.PrivilegesRequired = QtPtObjects.QMetric(QtPtCore.QtPt.PrivilegesRequiredMetric, 'Privileges Required', 3)
            self.UserInteraction = QtPtObjects.QMetric(QtPtCore.QtPt.UserInteractionMetric, 'User Interaction', 3)
            self.Scope = QtPtObjects.QMetric(QtPtCore.QtPt.ScopeMetric, 'Scope', 3)
            self.Confidentiality = QtPtObjects.QMetric(QtPtCore.QtPt.ConfidentialityMetric, 'Confidentiality', 3)
            self.Integrity = QtPtObjects.QMetric(QtPtCore.QtPt.IntegrityMetric, 'Integrity', 3)
            self.Availability = QtPtObjects.QMetric(QtPtCore.QtPt.AvailabilityMetric, 'Availability', 3)

        for key, value in self._data.get('metrics', dict()).items():
            self.set(key, value)

        return self

    def write(self) -> 'QCvss':
        """ Save CVSS metrics into the database file.
        The data will be stored in JSON and the file will be overwritten.

        Returns:
            QCvss: The current class

        """
        self._data = self.dict()
        with open(self.absoluteFilePath(), 'w') as file:
            json.dump(self._data, file, indent=4)
        return self

    def version(self) -> int:
        """ Getter for a CVSS version.

        Returns:
            int: The current version

        """
        return int(self._version)

    def setVersion(self, version: int) -> None:
        """ Getter for a CVSS version.

        Args:
            version (int): The version to set

        """
        self._version = max(2, min(3, int(version)))

    def get(self, sid: 'QtPtCore.QCvssMetric') -> 'QtPtObjects.QMetric':
        """ Getter for a CVSS score.

        Args:
            sid (QtPtCore.QCvssMetric): The name of the metric, or a QMetric object

        Returns:
            QtPtObjects.QMetric: The requested metric

        """
        return getattr(self, self.metricName(sid)) if isinstance(getattr(self, self.metricName(sid), None), QtPtObjects.QMetric) else QtPtObjects.QMetric(sid)

    def set(self, key: object, value: str) -> None:
        """ Setter for a CVSS score.

        Args:
            key (object): The name of the metric, or a QMetric object
            value (str): The value of the metric

        """
        if isinstance(getattr(self, self.metricName(key), None), QtPtObjects.QMetric):
            getattr(self, self.metricName(key)).setSelected(value)
        else:
            setattr(self, self.metricName(key), QtPtObjects.QMetric(key, selected=value))

    def dict(self) -> {str: object}:
        """ Array representation for the class

        Returns:
            {str: object}: The current class as an array

        """
        return { 'version': self.version(), 'score': self.score(), 'metrics': self.getMetrics() }

    def __str__(self) -> str:
        """ String representation for the class.

        Returns:
            str: The current class as a string

        """
        if self.version() == 2:
            return 'AV:{AV}/AC:{AC}/Au:{Au}/C:{C}/I:{I}/A:{A}'.format(**self.getMetrics()) if self.isCompleted() else 'N/A'
        if self.version() == 3:
            return 'AV:{AV}/AC:{AC}/PR:{PR}/UI:{UI}/S:{S}/C:{C}/I:{I}/A:{A}'.format(**self.getMetrics()) if self.isCompleted() else 'N/A'
        return '#VALUE!'

    def getMetrics(self) -> {'QtPtCore.QCvssMetric': 'QtPtCore.QCvssMetricValue'}:
        """ Get the current CVSS metrics.

        Returns:
            {QtPtCore.QCvssMetric: QtPtCore.QCvssMetricValue}: The CVSS metrics

        """
        if self.version() == 2:
            return {
                QtPtCore.QtPt.AttackVectorMetric: self.AttackVector.getSelected(),
                QtPtCore.QtPt.AttackComplexityMetric: self.AttackComplexity.getSelected(),
                QtPtCore.QtPt.AuthenticationMetric: self.Authentication.getSelected(),
                QtPtCore.QtPt.ConfidentialityMetric: self.Confidentiality.getSelected(),
                QtPtCore.QtPt.IntegrityMetric: self.Integrity.getSelected(),
                QtPtCore.QtPt.AvailabilityMetric: self.Availability.getSelected()
            }
        if self.version() == 3:
            return {
                QtPtCore.QtPt.AttackVectorMetric: self.AttackVector.getSelected(),
                QtPtCore.QtPt.AttackComplexityMetric: self.AttackComplexity.getSelected(),
                QtPtCore.QtPt.PrivilegesRequiredMetric: self.PrivilegesRequired.getSelected(),
                QtPtCore.QtPt.UserInteractionMetric: self.UserInteraction.getSelected(),
                QtPtCore.QtPt.ScopeMetric: self.Scope.getSelected(),
                QtPtCore.QtPt.ConfidentialityMetric: self.Confidentiality.getSelected(),
                QtPtCore.QtPt.IntegrityMetric: self.Integrity.getSelected(),
                QtPtCore.QtPt.AvailabilityMetric: self.Availability.getSelected()
            }
        return dict()

    def metricName(self, sid: 'QtPtCore.QCvssMetric') -> str:
        """ Get the metric's name of the given object.

        Args:
            sid (QtPtCore.QCvssMetric): The object QtPtCore.QtPt.*Metric

        Returns:
            str: The associated metric's name

        """
        return {
            QtPtCore.QtPt.AttackVectorMetric: 'AttackVector',
            QtPtCore.QtPt.AttackComplexityMetric: 'AttackComplexity',
            QtPtCore.QtPt.AuthenticationMetric: 'Authentication',
            QtPtCore.QtPt.PrivilegesRequiredMetric: 'PrivilegesRequired',
            QtPtCore.QtPt.UserInteractionMetric: 'UserInteraction',
            QtPtCore.QtPt.ScopeMetric: 'Scope',
            QtPtCore.QtPt.ConfidentialityMetric: 'Confidentiality',
            QtPtCore.QtPt.IntegrityMetric: 'Integrity',
            QtPtCore.QtPt.AvailabilityMetric: 'Availability'
        }.get(sid, QtPtCore.QCvssMetric(sid))

    def score(self) -> float:
        """ Compute the CVSS score.

        Returns:
            float: The CVSS score

        """
        impact = self.scoreImpact()
        exploitability = self.scoreExploitability()
        if self.version() == 2:
            if impact > 0.0 and self.isCompleted():
                return math.ceil(min(1.176 * (0.6 * impact + 0.4 * exploitability - 1.5), 10.0) * 10)/10
        if self.version() == 3:
            if impact > 0.0 and self.isCompleted():
                if self.Scope.isSelected(QtPtCore.QtPt.UnchangedMetricValue):
                    return math.ceil(min((impact + exploitability), 10.0) * 10)/10
                elif self.Scope.isSelected(QtPtCore.QtPt.ChangedMetricValue):
                    return math.ceil(min(1.08 * (impact + exploitability), 10.0) * 10)/10
        return 0.0

    def scoreImpact(self) -> float:
        """ Compute the CVSS impact score.

        Returns:
            float: The CVSS impact score

        """
        score = 1 - ((1 - self.Confidentiality.score()) * (1 - self.Integrity.score()) * (1 - self.Availability.score()))
        if self.version() == 2:
            return 10.41 * score
        if self.version() == 3:
            if self.Scope.isSelected(QtPtCore.QtPt.UnchangedMetricValue):
                return 6.42 * score
            elif self.Scope.isSelected(QtPtCore.QtPt.ChangedMetricValue):
                return 7.52 * (score - 0.029) - 3.25 * (score - 0.02)**15
        return 0.0

    def scoreExploitability(self) -> float:
        """ Compute the CVSS exploitability score.

        Returns:
            float: The CVSS exploitability score

        """
        if self.version() == 2:
            return 20 * self.AttackVector.score() * self.AttackComplexity.score() * self.Authentication.score()
        if self.version() == 3:
            score = 8.22 * self.AttackVector.score() * self.AttackComplexity.score() * self.UserInteraction.score()
            if self.Scope.isSelected(QtPtCore.QtPt.UnchangedMetricValue):
                return score * self.PrivilegesRequired.score((0.0, 0.0))[0]
            elif self.Scope.isSelected(QtPtCore.QtPt.ChangedMetricValue):
                return score * self.PrivilegesRequired.score((0.0, 0.0))[1]
        return 0.0

    def isCompleted(self) -> bool:
        """ Check if the CVSS criteria are all selected.

        Returns:
            bool: Tre if the CVSS score can be computed, False otherwise

        """
        return None not in self.getMetrics().values()

    def color(self, score: float = None) -> 'QtPtCore.QCvssColor':
        """ Get the color associated to the given score.
        If no score is provided, the current object score is used.

        Args:
            score (float, optional): The CVSS score of which the color is wanted (default None)

        Returns:
            QtPtCore.QCvssColor: The requested color

        """
        score = score if isinstance(score, float) else self.score()
        if 9.0 < score:
            return QtPtCore.QtPt.CriticalColor
        if 7.0 < score:
            return QtPtCore.QtPt.HighColor
        if 4.0 < score:
            return QtPtCore.QtPt.MediumColor
        if 0.1 < score:
            return QtPtCore.QtPt.LowColor
        if self.isCompleted():
            return QtPtCore.QtPt.NoneColor
        return QtPtCore.QtPt.DefaultColor

    def rating(self, score = None) -> 'QtPtCore.QCvssRating':
        """ Get the rating associated to the given score.
        If no score is provided, the current object score is used.

        Args:
            score (float, optional): The CVSS score of which the rating is wanted (default None)

        Returns:
            QtPtCore.QCvssRating: The requested rating

        """
        score = score if isinstance(score, float) else self.score()
        if 9.0 < score:
            return QtPtCore.QtPt.CriticalRating
        if 7.0 < score:
            return QtPtCore.QtPt.HighRating
        if 4.0 < score:
            return QtPtCore.QtPt.MediumRating
        if 0.1 < score:
            return QtPtCore.QtPt.LowRating
        if self.isCompleted():
            return QtPtCore.QtPt.NoneRating
        return QtPtCore.QtPt.DefaultRating

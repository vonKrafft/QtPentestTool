# Copyright (c) 2019 vonKrafft <contact@vonkrafft.fr>
# 
# This file is part of QtPentestTool.
# 
# This file may be used under the terms of the GNU General Public License
# version 3.0 as published by the Free Software Foundation and appearing in
# the file LICENSE included in the packaging of this file. Please review the
# following information to ensure the GNU General Public License version 3.0
# requirements will be met: http://www.gnu.org/copyleft/gpl.html.
# 
# This file is provided AS IS with NO WARRANTY OF ANY KIND, INCLUDING THE
# WARRANTY OF DESIGN, MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.

from .. import QtPtCore
from .. import QtPtObjects

import json
import math
import os
import tempfile


class QCvss(object):
    """ Model object for a CVSS score """

    def __init__(self, folder = None, database = 'cvss.json', version = 3):
        """ Class constructor

        Keyword arguments:
        folder -- the folder in which to save the database file (default <tempdir>/.qcvss)
        database -- the file to store CVSS metrics (default 'cvss.json')
        version -- the CVSS version to use (default '3')
        """
        folder = os.path.join(tempfile.gettempdir(), '.qcvss') if folder is None else folder
        self.version = max(2, min(3, int(version)))

        self.database = os.path.abspath(os.path.join(os.path.abspath(folder), os.path.basename(database)))
        self.data = { 'version': self.version, 'score': 0.0, 'metrics': dict() }

        self.AttackVector = QtPtObjects.QMetric()
        self.AttackComplexity = QtPtObjects.QMetric()
        self.Authentication = QtPtObjects.QMetric()
        self.PrivilegesRequired = QtPtObjects.QMetric()
        self.UserInteraction = QtPtObjects.QMetric()
        self.Scope = QtPtObjects.QMetric()
        self.Confidentiality = QtPtObjects.QMetric()
        self.Integrity = QtPtObjects.QMetric()
        self.Availability = QtPtObjects.QMetric()

    def read(self):
        """ Retrieve CVSS metrics from the database file
        The file has to exist and be JSON

        Return:
        the current class
        """
        with open(self.database, 'r') as file:
            self.data = json.load(file)

        self.version = max(2, min(3, int(self.data.get('version', 3))))

        if self.version == 2:
            self.AttackVector = QtPtObjects.QMetric(QtPtCore.QtPt.AttackVectorMetric, 'Access Vector', 2)
            self.AttackComplexity = QtPtObjects.QMetric(QtPtCore.QtPt.AttackComplexityMetric, 'Access Complexity', 2)
            self.Authentication = QtPtObjects.QMetric(QtPtCore.QtPt.AuthenticationMetric, 'Authentication', 2)
            self.Confidentiality = QtPtObjects.QMetric(QtPtCore.QtPt.ConfidentialityMetric, 'Confidentiality', 2)
            self.Integrity = QtPtObjects.QMetric(QtPtCore.QtPt.IntegrityMetric, 'Integrity', 2)
            self.Availability = QtPtObjects.QMetric(QtPtCore.QtPt.AvailabilityMetric, 'Availability', 2)
        elif self.version == 3:
            self.AttackVector = QtPtObjects.QMetric(QtPtCore.QtPt.AttackVectorMetric, 'Attack Vector', 3)
            self.AttackComplexity = QtPtObjects.QMetric(QtPtCore.QtPt.AttackComplexityMetric, 'Attack Complexity', 3)
            self.PrivilegesRequired = QtPtObjects.QMetric(QtPtCore.QtPt.PrivilegesRequiredMetric, 'Privileges Required', 3)
            self.UserInteraction = QtPtObjects.QMetric(QtPtCore.QtPt.UserInteractionMetric, 'User Interaction', 3)
            self.Scope = QtPtObjects.QMetric(QtPtCore.QtPt.ScopeMetric, 'Scope', 3)
            self.Confidentiality = QtPtObjects.QMetric(QtPtCore.QtPt.ConfidentialityMetric, 'Confidentiality', 3)
            self.Integrity = QtPtObjects.QMetric(QtPtCore.QtPt.IntegrityMetric, 'Integrity', 3)
            self.Availability = QtPtObjects.QMetric(QtPtCore.QtPt.AvailabilityMetric, 'Availability', 3)

        for key, value in self.data.get('metrics', dict()).items():
            self.set(key, value)

        return self

    def write(self):
        """ Save CVSS metrics into the database file
        The data will be stored in JSON and the file will be overwritten

        Return:
        the current class
        """
        self.data = self.dict()
        with open(self.database, 'w') as file:
            json.dump(self.data, file, indent=4)
        return self

    def get(self, key):
        """ Getter for a CVSS metric

        Keyword arguments:
        key -- the name of the metric

        Return:
        the value of the requested metric
        """
        return getattr(self, self.metricName(key)) if isinstance(getattr(self, self.metricName(key), None), QtPtObjects.QMetric) else QtPtObjects.QMetric(key)

    def set(self, key, value):
        """ Setter for a CVSS metric

        Keyword arguments:
        key -- the name of the metric
        value -- the value of the metric
        """
        if isinstance(getattr(self, self.metricName(key), None), QtPtObjects.QMetric):
            getattr(self, self.metricName(key)).setSelected(value)
        else:
            setattr(self, self.metricName(key), QtPtObjects.QMetric(key, selected=value))

    def dict(self):
        """ Array representation for the class

        Return:
        the current class as an array
        """
        return { 'version': self.version, 'score': self.score(), 'metrics': self.getMetrics() }

    def __str__(self):
        """ String representation for the class

        Return
        the current class as a string
        """
        if self.version == 2:
            return 'AV:{AV}/AC:{AC}/Au:{Au}/C:{C}/I:{I}/A:{A}'.format(**self.getMetrics()) if self.isCompleted() else 'N/A'
        if self.version == 3:
            return 'AV:{AV}/AC:{AC}/PR:{PR}/UI:{UI}/S:{S}/C:{C}/I:{I}/A:{A}'.format(**self.getMetrics()) if self.isCompleted() else 'N/A'
        return '#VALUE!'

    def getMetrics(self):
        if self.version == 2:
            return {
                QtPtCore.QtPt.AttackVectorMetric: self.AttackVector.getSelected(),
                QtPtCore.QtPt.AttackComplexityMetric: self.AttackComplexity.getSelected(),
                QtPtCore.QtPt.AuthenticationMetric: self.Authentication.getSelected(),
                QtPtCore.QtPt.ConfidentialityMetric: self.Confidentiality.getSelected(),
                QtPtCore.QtPt.IntegrityMetric: self.Integrity.getSelected(),
                QtPtCore.QtPt.AvailabilityMetric: self.Availability.getSelected()
            }
        if self.version == 3:
            return {
                QtPtCore.QtPt.AttackVectorMetric: self.AttackVector.getSelected(),
                QtPtCore.QtPt.AttackComplexityMetric: self.AttackComplexity.getSelected(),
                QtPtCore.QtPt.PrivilegesRequiredMetric: self.PrivilegesRequired.getSelected(),
                QtPtCore.QtPt.UserInteractionMetric: self.UserInteraction.getSelected(),
                QtPtCore.QtPt.ScopeMetric: self.Scope.getSelected(),
                QtPtCore.QtPt.ConfidentialityMetric: self.Confidentiality.getSelected(),
                QtPtCore.QtPt.IntegrityMetric: self.Integrity.getSelected(),
                QtPtCore.QtPt.AvailabilityMetric: self.Availability.getSelected()
            }
        return dict()

    def metricName(self, metric):
        return {
            QtPtCore.QtPt.AttackVectorMetric: 'AttackVector',
            QtPtCore.QtPt.AttackComplexityMetric: 'AttackComplexity',
            QtPtCore.QtPt.AuthenticationMetric: 'Authentication',
            QtPtCore.QtPt.PrivilegesRequiredMetric: 'PrivilegesRequired',
            QtPtCore.QtPt.UserInteractionMetric: 'UserInteraction',
            QtPtCore.QtPt.ScopeMetric: 'Scope',
            QtPtCore.QtPt.ConfidentialityMetric: 'Confidentiality',
            QtPtCore.QtPt.IntegrityMetric: 'Integrity',
            QtPtCore.QtPt.AvailabilityMetric: 'Availability'
        }.get(metric, str(metric))

    def score(self):
        impact = self.scoreImpact()
        exploitability = self.scoreExploitability()
        if self.version == 2:
            if impact > 0.0 and self.isCompleted():
                return math.ceil(min(1.176 * (0.6 * impact + 0.4 * exploitability - 1.5), 10.0) * 10)/10
        if self.version == 3:
            if impact > 0.0 and self.isCompleted():
                if self.Scope.isSelected(QtPtCore.QtPt.UnchangedMetricValue):
                    return math.ceil(min((impact + exploitability), 10.0) * 10)/10
                elif self.Scope.isSelected(QtPtCore.QtPt.ChangedMetricValue):
                    return math.ceil(min(1.08 * (impact + exploitability), 10.0) * 10)/10
        return 0.0

    def scoreImpact(self):
        score = 1 - ((1 - self.Confidentiality.score()) * (1 - self.Integrity.score()) * (1 - self.Availability.score()))
        if self.version == 2:
            return 10.41 * score
        if self.version == 3:
            if self.Scope.isSelected(QtPtCore.QtPt.UnchangedMetricValue):
                return 6.42 * score
            elif self.Scope.isSelected(QtPtCore.QtPt.ChangedMetricValue):
                return 7.52 * (score - 0.029) - 3.25 * (score - 0.02)**15
        return 0.0

    def scoreExploitability(self):
        if self.version == 2:
            return 20 * self.AttackVector.score() * self.AttackComplexity.score() * self.Authentication.score()
        if self.version == 3:
            score = 8.22 * self.AttackVector.score() * self.AttackComplexity.score() * self.UserInteraction.score()
            if self.Scope.isSelected(QtPtCore.QtPt.UnchangedMetricValue):
                return score * self.PrivilegesRequired.score((0.0, 0.0))[0]
            elif self.Scope.isSelected(QtPtCore.QtPt.ChangedMetricValue):
                return score * self.PrivilegesRequired.score((0.0, 0.0))[1]
        return 0.0

    def isCompleted(self):
        return None not in self.getMetrics().values()

    def color(self, score = None):
        score = score if isinstance(score, float) else self.score()
        if 9.0 < score:
            return QtPtCore.QtPt.CriticalColor
        if 7.0 < score:
            return QtPtCore.QtPt.HighColor
        if 4.0 < score:
            return QtPtCore.QtPt.MediumColor
        if 0.1 < score:
            return QtPtCore.QtPt.LowColor
        if self.isCompleted():
            return QtPtCore.QtPt.NoneColor
        return QtPtCore.QtPt.DefaultColor

    def rating(self, score = None):
        score = score if isinstance(score, float) else self.score()
        if 9.0 < score:
            return QtPtCore.QtPt.CriticalRating
        if 7.0 < score:
            return QtPtCore.QtPt.HighRating
        if 4.0 < score:
            return QtPtCore.QtPt.MediumRating
        if 0.1 < score:
            return QtPtCore.QtPt.LowRating
        if self.isCompleted():
            return QtPtCore.QtPt.NoneRating
        return QtPtCore.QtPt.DefaultRating

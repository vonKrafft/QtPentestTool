# Copyright (c) 2019 vonKrafft <contact@vonkrafft.fr>
# 
# This file is part of QtPentestTool.
# 
# This file may be used under the terms of the GNU General Public License
# version 3.0 as published by the Free Software Foundation and appearing in
# the file LICENSE included in the packaging of this file. Please review the
# following information to ensure the GNU General Public License version 3.0
# requirements will be met: http://www.gnu.org/copyleft/gpl.html.
# 
# This file is provided AS IS with NO WARRANTY OF ANY KIND, INCLUDING THE
# WARRANTY OF DESIGN, MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.

from PyQt5 import QtCore

from .. import QtPtObjects

import glob
import os
import re # PyQt5.QtCore.QRegExp has no replace method, thus "re" is needed
import shutil
import subprocess
import time
import markdown


class QVulnerability(QtCore.QDir):
    """ Model object for a vulnerability.

    Attributes:
        _database (QtCore.QFileInfo): The file to store vulnerability's information
        _data ({str: str}): Data stored in the Markdown file
        _description (str): The vulnerability's description
        _impact (str): The vulnerability's impact
        _remediation (str): The vulnerability's remediation
        _cvss (QtPtObjects.QCvss): The vulnerability's CVSS score

    Constants:
        OWASP ([str]): The OWASP Top 10 2017

    """

    """ The file to store vulnerability's information """
    _database = None

    """ OWASP Top 10 2017 """
    OWASP = [
        'A1:2017-Injection',
        'A2:2017-Broken Authentication',
        'A3:2017-Sensitive Data Exposure',
        'A4:2017-XML External Entities (XXE)',
        'A5:2017-Broken Access Control',
        'A6:2017-Security Misconfiguration',
        'A7:2017-Cross-Site Scripting (XSS)',
        'A8:2017-Insecure Deserialization',
        'A9:2017-Using Components with Known Vulnerabilities',
        'A10:2017-Insufficient Logging & Monitoring'
    ]

    def __init__(self, folder: str, database: str = 'info.md', version: int = 3, *args, **kwargs) -> None:
        """ Class constructor.

        Args:
            folder (str): The folder in which to save information and vulnerability's resources
            database (str): The file to store vulnerability's information (default 'info.md')
            version (int): The CVSS version to use (default '3')
            *args: Variable length argument list
            **kwargs: Arbitrary keyword arguments

        """
        super(QVulnerability, self).__init__(*args, **kwargs)

        self.setPath(QtCore.QDir.tempPath() if folder is None else folder)
        self.setDatabase(database)

        self._data = { 'Name': '', 'URL': '', 'Account': '', 'OWASP': '' }
        self._description = ''
        self._impact = ''
        self._remediation = ''
        self._cvss = QtPtObjects.QCvss(folder=folder, version=version)

    def setDatabase(self, file: object) -> None:
        """ Setter for the vulnerability's database

        Args:
            file (str | QtCore.QFileInfo): The database object to set

        """
        if not isinstance(file, QtCore.QFileInfo):
            file = self.absoluteFilePath(QtCore.QFileInfo(str(file)).fileName())
        self._database = QtCore.QFileInfo(file)

    def database(self) -> 'QtCore.QFileInfo':
        """ Getter for the vulnerability's database object

        Returns:
            QtCore.QFileInfo: The current database object

        """
        return self._database;

    def databasePath(self) -> str:
        """ Getter for the vulnerability's database path

        Returns:
            str: The current database path

        """
        return self._database.absoluteFilePath()

    def cvss(self) -> 'QtPtObjects.QCvss':
        """ Getter for the vulnerability's CVSS object

        Returns:
            QtPtObjects.QCvss: The current vulnerability's CVSS object

        """
        return self._cvss

    def __hash__(self) -> int:
        """ Defines behavior for when hash() is called on an instance of this class.

        Returns:
            int: The hash of the vulnerability's database path

        """
        return hash(self.databasePath())

    def __eq__(self, other: 'QVulnerability') -> bool:
        """ Defines behavior for the equality operator (==).

        Args:
            other (QVulnerability): The object to compare with

        Returns:
            bool: True if the current is equal to other, False otherwise

        """
        return hash(self) == hash(other)

    def __ne__(self, other: 'QVulnerability') -> bool:
        """ Defines behavior for the inequality operator (!=).

        Args:
            other (QVulnerability): The object to compare with

        Returns:
            bool: False if the current is equal to other, True otherwise

        """
        return hash(self) != hash(other)

    def __str__(self) -> str:
        """ String representation for the class.

        Returns:
            str: The current class as a string

        """
        return f'{self._cvss.score()} ({self._cvss.rating()}): {self.get("name", "")}'

    def read(self) -> 'QVulnerability':
        """ Retrieve vulnerability's information from the database file.
        The file has to exist and be Markdown.

        Returns:
            QVulnerability: The current class

        """
        with open(self.databasePath(), 'rb') as file:
            content = file.read().decode('utf-8')

        content = re.sub(r'^---$', '-'*80, content, flags=re.MULTILINE)
        content = content.replace('# Description', '').replace('# Impact', '-'*80).replace('# Remediation', '-'*80)
        sections = content.split(f"\n{'-'*80}")

        headers = sections[0].replace('-'*80, '').strip('\n')
        self._description = sections[1].strip('\n') if len(sections) > 1 else ''
        self._impact = sections[2].strip('\n') if len(sections) > 2 else ''
        self._remediation = sections[3].strip('\n') if len(sections) > 3 else ''

        regex = QtCore.QRegExp(r'^([^:]+): *([^ ].*)$')
        for h in headers.split('\n'):
            if regex.indexIn(h) >= 0:
                self._data[regex.cap(1)] = regex.cap(2)

        if not self._cvss.exists():
            self._cvss.write()
        self._cvss.read()

        return self

    def write(self) -> 'QVulnerability':
        """ Save vulnerability's information into the database file.
        The data will be stored in Markdown and the file will be overwritten.

        Returns:
            QVulnerability: The current class

        """
        with open(self.databasePath(), 'wb') as file:
            file.write(f'''---\n{chr(10).join([f'{key}: {self._data[key]}' for key in self._data])}\n---'''.encode('utf-8'))
            file.write(f'''\n\n# Description\n\n{self._description}'''.encode('utf-8'))
            file.write(f'''\n\n# Impact\n\n{self._impact}'''.encode('utf-8'))
            file.write(f'''\n\n# Remediation\n\n{self._remediation}'''.encode('utf-8'))
        self._cvss.write()
        self.generateHtml()
        return self

    def create(self) -> bool:
        """ Create a new vulnerability

        Returns:
            bool: True if the vulnerability was created, False otherwise

        """
        vulnDest = QtCore.QFileInfo(self.absolutePath())

        if not vulnDest.isDir():
            vulnDest.dir().mkdir(vulnDest.fileName())
            self.setPath(vulnDest.absoluteFilePath())
            self.mkdir('screenshots')
            self.write()
            return True

        return False

    def delete(self) -> bool:
        """ Delete the vulnerability

        Returns:
            bool: True if the vulnerability was deleted, False otherwise

        """
        try:
            isRemoved = self.removeRecursively()
            while self.exists():
                time.sleep(0.01)
        except:
            return False
        return isRemoved

    def move(self, newName: str) -> bool:
        """ Rename the vulnerability's folder

        Args:
            newName (str): The new folder

        Returns:
            bool: True if the vulnerability was moved, False otherwise

        """
        if not QtCore.QFileInfo(newName).isDir():
            self.rename(self.absolutePath(), newName)
            self.setDatabase(self.databasePath())
            self._cvss.setFile(self, self._cvss.fileName())
            return True
        return False

    def get(self, key: str, default: object = None) -> object:
        """ Getter for a vulnerability property

        Args:
            key (str): The name of the property
            default (object): The default value if the property does not exist

        Returns:
            object: The value of the requested property

        """
        tmp = dict(map(lambda kv: (kv[0].lower(), kv[1]), self._data.items()))
        return tmp.get(key.lower(), default)

    def set(self, key: str, value: object) -> None:
        """ Setter for a vulnerability property

        Args:
            key (str): The name of the property
            value (object): The value of the property

        """
        self._data[key] = value

    def parentDir(self) -> 'QtCore.QDir' :
        """ Get the parent directory

        Returns:
            QtCore.QDir: The parent directory

        """
        currentDir = QtCore.QDir(self.absolutePath())
        currentDir.cdUp()
        return currentDir

    def parentPath(self) -> str :
        """ Get the parent directory absolute path

        Returns:
            str: The parent directory absolute path

        """
        return self.parentDir().absolutePath()

    @staticmethod
    def enum(root: str, database: str = 'info.md') -> [str]:
        """ List all the directories in `root` that have the `database` file.

        Args:
            root (str): The folder in which to search for vulnerabilities
            database (str): The name of the database file that defines a vulnerability as such (default 'info.md')

        Returns:
            [str]: An array of the found vulnerabilities

        """
        root = QtCore.QDir(root)
        if root.exists():
            dirList = root.entryInfoList(QtCore.QDir.Dirs | QtCore.QDir.NoDotAndDotDot)
            return [d.absoluteFilePath() for d in dirList if QtCore.QDir(d.absoluteFilePath()).exists(database)]
        return []

    @staticmethod
    def isVulnerability(folder: str, database: str = 'info.md') -> bool:
        """ Check if the given folder is a valid vulnerability database.

        Args:
            folder (str): The folder in which to save information and vulnerability's resources
            database (str): The file to store vulnerability's information (default 'info.md')

        Returns:
            bool: True if the given folder contains the 'database' file, False otherwise

        """
        return QtCore.QDir(folder).exists(database)

    def screenshotsPath(self) -> str:
        """ Get the directory in which the scans are stored.

        Returns:
            str: The scans directory

        """
        return self.absoluteFilePath('screenshots')

    def sanitizeScreenshotPath(self, filepath: str) -> str:
        """ Sanitize a screenshot filepath to make sure it is in the appropriate folder.

        Args:
            filepath (str): The filepath to sanitize

        Returns:
            str: The sanitized path

        """
        filepath = QtCore.QDir(filepath).dirName()
        return QtCore.QDir(self.screenshotsPath()).absoluteFilePath(filepath)

    def listScreenshots(self) -> [str]:
        """ Get taken screenshots list.

        Returns:
            [str]: The list of PNG file in the screenshots folder

        """
        if QtCore.QFileInfo(self.screenshotsPath()).isDir():
            return QtCore.QDir(self.screenshotsPath()).entryList(['*.png'])
        return []

    def countScreenshots(self) -> int:
        """ Count the number of screenshots taken.

        Returns:
            int: The number of PNG file in the screenshots folder

        """
        return len(self.listScreenshots())

    def takeScreenshot(self) -> str:
        """ Take a screenshot.
        The used software is `scrot` and need to be installed.

        Returns:
            str: The filename of the taken screenshot

        """
        picture = None
        if not QtCore.QFileInfo(self.screenshotsPath()).isDir():
            self.mkdir('screenshots')
        if QtCore.QFileInfo('/usr/bin/scrot').isExecutable():
            command = [
                '/usr/bin/scrot', 
                'Screenshot_%Y%m%d_%H%M%S.png', 
                '-e', f'mv "$f" "{self.screenshotsPath()}"; echo "$f"'
            ]
            with subprocess.Popen(command, stdout=subprocess.PIPE) as process:
                picture = process.stdout.read().decode('utf-8').strip('\n')
                picture = QtCore.QDir(self.screenshotsPath()).absoluteFilePath(picture)
        return picture

    def generateHtml(self) -> str:
        """ Generate a HTML preview for the current vuln

        Returns:
            str: The filename of the HTML file

        """
        content = list()
        content.append(f'''# {self._data['Name'] if 'Name' in self._data else '[!NO_NAME]'}''')
        content.append(f'''<header>''')
        content.append(f'''<p>\n{chr(10).join([f'<b>{key}</b>: {self._data[key]}<br />' for key in self._data if key != 'Name'])}\n</p>''')
        content.append(f'''<p><span style="background:{self._cvss.color()}">{self._cvss.rating()} ({self._cvss.score()})</span> <b>CVSS v{self._cvss.version()}</b>: <a href="https://nvd.nist.gov/vuln-metrics/cvss/v{self._cvss.version()}-calculator?vector={self._cvss}" target="_blank">{self._cvss}</a></p>''')
        content.append(f'''</header>''')
        content.append(f'''## Description''')
        content.append(f'''{self._description}''')
        content.append(f'''## Impact''')
        content.append(f'''{self._impact}''')
        content.append(f'''## Remediation''')
        content.append(f'''{self._remediation}''')

        css = 'body{font-family:-apple-system,BlinkMacSystemFont,Segoe UI,Helvetica,Arial,sans-serif,Apple Color Emoji,Segoe UI Emoji;width:990px;margin:1rem auto;text-align:justify;padding:2rem;border:1px solid #d1d5da;border-radius:3px;background-color:#fff;font-size:16px;line-height:1.5;word-wrap:break-word}body *{max-width:100%}header{background:#f6f8fa;border:1px solid #eaecef;padding:.5rem 1rem;border-radius:3px}pre{padding:1rem;overflow:auto;font-size:85%;line-height:1.45;background-color:#f6f8fa;max-width:100%;word-wrap:break-word;white-space:pre-wrap}p>code,p>tt{padding:0.2em 0.4em;margin:0;font-size:85%;background-color:rgba(27,31,35,.05);border-radius:3px}blockquote{padding:0 1em;color:#6a737d;border-left:0.25em solid #dfe2e5}h1,h2{padding-bottom:0.3em;border-bottom:1px solid #eaecef}h1{font-size:2em}h2{font-size:1.5em}h1:first-child{margin-top:0}span{padding:.5em 1em;border-radius:3px;color:#fff}'
        title = self._data['Name'] if 'Name' in self._data else '[!NO_NAME]'
        body = markdown.markdown('\n\n'.join(content))

        html = f'''<!DOCTYPE html>\n<html>\n<head>\n<title>{title}</title>\n<style type="text/css">{css}</style>\n</head>\n<body>{body}\n</body>\n</html>'''

        filepath = f'''{self.databasePath().rstrip('.md')}.html'''
        with open(filepath, 'wb') as file:
            file.write(html.encode('utf-8'))

        return filepath

    @staticmethod
    def sanitizeVulnerabilityFolder(text: str) -> str:
        """ Sanitize string to use it as directory or file name
        - Replace spaces with underscores
        - Remove non-word characters (keep A-Z, a-z, 0-9 and _)
        - Check for any multiples underscores
        - Remove underscores at the beginning and the end of the string

        Args:
            text (str): The input string

        Returns:
            str: The sanitized string

        """
        return re.sub(r'__+', '_', re.sub(r'[^A-Za-z0-9_]+', '', text.replace(' ', '_'))).strip('_')

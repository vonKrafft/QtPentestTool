# Copyright (c) 2019 vonKrafft <contact@vonkrafft.fr>
# 
# This file is part of QtPentestTool.
# 
# This file may be used under the terms of the GNU General Public License
# version 3.0 as published by the Free Software Foundation and appearing in
# the file LICENSE included in the packaging of this file. Please review the
# following information to ensure the GNU General Public License version 3.0
# requirements will be met: http://www.gnu.org/copyleft/gpl.html.
# 
# This file is provided AS IS with NO WARRANTY OF ANY KIND, INCLUDING THE
# WARRANTY OF DESIGN, MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.

from PyQt5 import QtCore

from .. import QtPtObjects

import glob
import os
import re # PyQt5.QtCore.QRegExp has no replace method, thus "re" is needed
import shutil
import subprocess
import time


class QVulnerability(object):
    """ Model object for a vulnerability.

    Attributes:
        database (str): The file to store vulnerability's information
        data ({str: str}): Data stored in the Markdown file
        description (str): The vulnerability's description
        impact (str): The vulnerability's impact
        remediation (str): The vulnerability's remediation
        cvss (QtPtObjects.QCvss): The vulnerability's CVSS score

    Constants:
        OWASP ([str]): The OWASP Top 10 2017

    """

    """ OWASP Top 10 2017 """
    OWASP = [
        'A1:2017-Injection',
        'A2:2017-Broken Authentication',
        'A3:2017-Sensitive Data Exposure',
        'A4:2017-XML External Entities (XXE)',
        'A5:2017-Broken Access Control',
        'A6:2017-Security Misconfiguration',
        'A7:2017-Cross-Site Scripting (XSS)',
        'A8:2017-Insecure Deserialization',
        'A9:2017-Using Components with Known Vulnerabilities',
        'A10:2017-Insufficient Logging & Monitoring'
    ]

    def __init__(self, folder: str, database: str = 'info.md', version: int = 3) -> None:
        """ Class constructor.

        Args:
            folder (str): The folder in which to save information and vulnerability's resources
            database (str): The file to store vulnerability's information (default 'info.md')
            version (int): The CVSS version to use (default '3')

        """
        self.database = os.path.join(os.path.abspath(folder), os.path.basename(database))
        self.data = { 'Name': '', 'URL': '', 'Account': '', 'OWASP': '' }
        self.description = ''
        self.impact = ''
        self.remediation = ''
        self.cvss = QtPtObjects.QCvss(folder=folder, version=version)

    def __hash__(self) -> int:
        """ Defines behavior for when hash() is called on an instance of this class.

        Returns:
            int: The hash of the vulnerability's database path

        """
        return hash(self.database)

    def __eq__(self, other: 'QVulnerability') -> bool:
        """ Defines behavior for the equality operator (==).

        Args:
            other (QVulnerability): The object to compare with

        Returns:
            bool: True if the current is equal to other, False otherwise

        """
        return hash(self) == hash(other)

    def __ne__(self, other: 'QVulnerability') -> bool:
        """ Defines behavior for the inequality operator (!=).

        Args:
            other (QVulnerability): The object to compare with

        Returns:
            bool: False if the current is equal to other, True otherwise

        """
        return hash(self) != hash(other)

    def __str__(self) -> str:
        """ String representation for the class.

        Returns:
            str: The current class as a string

        """
        return f'{self.cvss.score()} ({self.cvss.rating()}): {self.get("name", "")}'

    def read(self) -> 'QVulnerability':
        """ Retrieve vulnerability's information from the database file.
        The file has to exist and be Markdown.

        Returns:
            QVulnerability: The current class

        """
        if os.path.isfile(self.database):
            with open(self.database, 'rb') as file:
                content = file.read().decode('utf-8')

            content = content.replace('---', '-'*80).replace('# Description', '').replace('# Impact', '-'*80).replace('# Remediation', '-'*80)
            sections = content.split(f"\n{'-'*80}")

            headers = sections[0].replace('-'*80, '').strip('\n')
            self.description = sections[1].strip('\n') if len(sections) > 1 else ''
            self.impact = sections[2].strip('\n') if len(sections) > 2 else ''
            self.remediation = sections[3].strip('\n') if len(sections) > 3 else ''

            regex = QtCore.QRegExp(r'^([^:]+): *([^ ].*)$')
            for h in headers.split('\n'):
                if regex.indexIn(h) >= 0:
                    self.data[regex.cap(1)] = regex.cap(2)

            if not os.path.isfile(self.cvss.database):
                self.cvss.write()
            self.cvss.read()
        return self

    def write(self) -> 'QVulnerability':
        """ Save vulnerability's information into the database file.
        The data will be stored in Markdown and the file will be overwritten.

        Returns:
            QVulnerability: The current class

        """
        with open(self.database, 'wb') as file:
            file.write(f'''---\n{chr(10).join([f'{key}: {self.data[key]}' for key in self.data])}\n---'''.encode('utf-8'))
            file.write(f'''\n\n# Description\n\n{self.description}'''.encode('utf-8'))
            file.write(f'''\n\n# Impact\n\n{self.impact}'''.encode('utf-8'))
            file.write(f'''\n\n# Remediation\n\n{self.remediation}'''.encode('utf-8'))
        self.cvss.write()
        return self

    def create(self) -> bool:
        """ Create a new vulnerability

        Returns:
            bool: True if the vulnerability was created, False otherwise

        """
        if not os.path.isdir(os.path.dirname(self.database)):
            os.makedirs(os.path.dirname(self.database), exist_ok=True)
            os.makedirs(os.path.join(os.path.dirname(self.database), 'screenshots'), exist_ok=True)
            self.write()
            return True
        return False

    def delete(self) -> bool:
        """ Delete the vulnerability

        Returns:
            bool: True if the vulnerability was deleted, False otherwise

        """
        try:
            shutil.rmtree(os.path.dirname(self.database))
            while os.path.isdir(os.path.dirname(self.database)):
                time.sleep(0.01)
        except:
            return False
        return True

    def rename(self, folder: str) -> bool:
        """ Rename the vulnerability's folder

        Args:
            folder (str): The new folder

        Returns:
            bool: True if the vulnerability was moved, False otherwise

        """
        oldFolder = os.path.dirname(self.database)
        newFolder = os.path.join(os.path.dirname(oldFolder), os.path.basename(folder))
        if not os.path.isdir(newFolder):
            shutil.move(oldFolder, newFolder)
            self.database = os.path.join(os.path.abspath(newFolder), os.path.basename(self.database))
            self.cvss.database = os.path.join(os.path.abspath(newFolder), os.path.basename(self.cvss.database))
            return True
        return False

    def get(self, key: str, default: object = None) -> object:
        """ Getter for a vulnerability property

        Args:
            key (str): The name of the property
            default (object): The default value if the property does not exist

        Returns:
            object: The value of the requested property

        """
        tmp = dict(map(lambda kv: (kv[0].lower(), kv[1]), self.data.items()))
        return tmp.get(key.lower(), default)

    def set(self, key: str, value: object) -> None:
        """ Setter for a vulnerability property

        Args:
            key (str): The name of the property
            value (object): The value of the property

        """
        self.data[key] = value

    def basename(self) -> str:
        """ Get the basename of the vulnerability's database
    
        Returns:
            str: The base name of the vulnerability's database

        """
        return os.path.basename(self.dirname())

    def dirname(self) -> str:
        """ Get the directory name of the vulnerability's database.
    
        Returns:
            str: The directory name of the vulnerability's database

        """
        return os.path.dirname(os.path.abspath(self.database))

    def relpath(self, filepath: str) -> str:
        """ Get the relative path of the given filepath from the directory of the vulnerability's database.

        Args:
            filepath (str): The filepath of which the relative path is wanted
    
        Returns:
            str: The relative path of the given filepath from the directory of the vulnerability's database

        """
        return os.path.relpath(filepath, self.dirname())

    @staticmethod
    def enum(root: str, database: str = 'info.md') -> [str]:
        """ List all the directories in `root` that have the `database` file.

        Args:
            root (str): The folder in which to search for vulnerabilities
            database (str): The name of the database file that defines a vulnerability as such (default 'info.md')

        Returns:
            [str]: An array of the found vulnerabilities

        """
        root = os.path.abspath(root)
        if os.path.isdir(root):
            return [os.path.dirname(f) for f in glob.glob(os.path.join(root, '*', database))]
        return []

    @staticmethod
    def isVulnerability(folder: str, database: str = 'info.md') -> bool:
        """ Check if the given folder is a valid vulnerability database.

        Args:
            folder (str): The folder in which to save information and vulnerability's resources
            database (str): The file to store vulnerability's information (default 'info.md')

        Returns:
            bool: True if the given folder contains the 'database' file, False otherwise

        """
        return os.path.isfile(os.path.join(os.path.abspath(folder), os.path.basename(database)))

    def getScreenshotsDir(self) -> str:
        """ Get the directory in which the scans are stored.

        Returns:
            str: The scans directory

        """
        return QtCore.QDir(f'{self.dirname()}/screenshots').absolutePath()

    def sanitizeScreenshotPath(self, filepath: str) -> str:
        """ Sanitize a screenshot filepath to make sure it is in the appropriate folder.

        Args:
            filepath (str): The filepath to sanitize

        Returns:
            str: The sanitized path

        """
        return os.path.join(self.getScreenshotsDir(), os.path.basename(filepath))

    def getScreenshotsList(self) -> [str]:
        """ Get taken screenshots list.

        Returns:
            [str]: The list of PNG file in the screenshots folder

        """
        if os.path.isdir(self.getScreenshotsDir()):
            return sorted([os.path.basename(f) for f in glob.glob(os.path.join(self.getScreenshotsDir(), '*.png'))])
        return []

    def countScreenshots(self) -> int:
        """ Count the number of screenshots taken.

        Returns:
            int: The number of PNG file in the screenshots folder

        """
        return len(self.getScreenshotsList())

    def takeScreenshot(self) -> str:
        """ Take a screenshot.
        The used software is `scrot` and need to be installed.

        Returns:
            str: The filename of the taken screenshot

        """
        picture = None
        if not os.path.isdir(self.getScreenshotsDir()):
            os.makedirs(self.getScreenshotsDir(), exist_ok=True)
        if os.path.isfile('/usr/bin/scrot'):
            command = [
                '/usr/bin/scrot', 
                'Screenshot_%Y%m%d_%H%M%S.png', 
                '-e', f'mv "$f" "{self.getScreenshotsDir()}"; echo "$f"'
            ]
            with subprocess.Popen(command, stdout=subprocess.PIPE) as process:
                picture = process.stdout.read().decode('utf-8').strip('\n')
                picture = os.path.join(self.getScreenshotsDir(), picture)
        return picture

    @staticmethod
    def sanitizeVulnerabilityFolder(text: str) -> str:
        """ Sanitize string to use it as directory or file name
        - Replace spaces with underscores
        - Remove non-word characters (keep A-Z, a-z, 0-9 and _)
        - Check for any multiples underscores
        - Remove underscores at the beginning and the end of the string

        Args:
            text (str): The input string

        Returns:
            str: The sanitized string

        """
        return re.sub(r'__+', '_', re.sub(r'[^A-Za-z0-9_]+', '', text.replace(' ', '_'))).strip('_')

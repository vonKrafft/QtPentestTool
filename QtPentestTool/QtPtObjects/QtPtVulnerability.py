# Copyright (c) 2019 vonKrafft <contact@vonkrafft.fr>
# 
# This file is part of QtPentestTool.
# 
# This file may be used under the terms of the GNU General Public License
# version 3.0 as published by the Free Software Foundation and appearing in
# the file LICENSE included in the packaging of this file. Please review the
# following information to ensure the GNU General Public License version 3.0
# requirements will be met: http://www.gnu.org/copyleft/gpl.html.
# 
# This file is provided AS IS with NO WARRANTY OF ANY KIND, INCLUDING THE
# WARRANTY OF DESIGN, MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.

from .. import QtPtObjects

import glob
import os
import re
import shutil
import subprocess
import time


class QVulnerability(object):
    """ Model object for a vulnerability """

    """ OWASP Top 10 2017 """
    OWASP = [
        'A1:2017-Injection',
        'A2:2017-Broken Authentication',
        'A3:2017-Sensitive Data Exposure',
        'A4:2017-XML External Entities (XXE)',
        'A5:2017-Broken Access Control',
        'A6:2017-Security Misconfiguration',
        'A7:2017-Cross-Site Scripting (XSS)',
        'A8:2017-Insecure Deserialization',
        'A9:2017-Using Components with Known Vulnerabilities',
        'A10:2017-Insufficient Logging & Monitoring'
    ]

    def __init__(self, folder, database = 'info.md', version = 3):
        """ Class constructor

        Keyword arguments:
        folder -- the folder in which to save information and vulnerability's resources
        database -- the file to store vulnerability's information (default 'info.md')
        version -- the CVSS version to use (default '3')
        """
        self.database = os.path.join(os.path.abspath(folder), os.path.basename(database))
        self.data = { 'Name': '', 'URL': '', 'Account': '', 'OWASP': '' }
        self.content = ''
        self.cvss = QtPtObjects.QCvss(folder=folder, version=version)

    def __hash__(self):
        """ Defines behavior for when hash() is called on an instance of this class

        Return:
        The hash of the vulnerability's database path
        """
        return hash(self.database)

    def __eq__(self, other):
        """ Defines behavior for the equality operator, ==

        Keyword arguments:
        other -- the object to compare with

        Return:
        True if the current is equal to other, False otherwise
        """
        return hash(self) == hash(other)

    def __ne__(self, other):
        """ Defines behavior for the inequality operator, !=

        Keyword arguments:
        other -- the object to compare with

        Return:
        False if the current is equal to other, True otherwise
        """
        return hash(self) == hash(other)

    def __str__(self):
        return f'{self.cvss.score()} ({self.cvss.rating()}): {self.get("name", "")}'

    def read(self):
        """ Retrieve vulnerability's information from the database file
        The file has to exist and be JSON

        Return:
        the current class
        """
        if os.path.isfile(self.database):
            with open(self.database, 'rb') as file:
                content = file.read().decode('utf-8')
                if 2 <= content.count('---'):
                    _, headers, self.content = content.split('---', 2)
                    for h in headers.split('\n'):
                        matches = re.search(r'^(?P<key>[^:]+): *(?P<value>.*)$', h)
                        if matches:
                            self.data[matches.group('key')] = matches.group('value')
                    self.content = self.content.strip('\n')
                else:
                    self.content = content
            if not os.path.isfile(self.cvss.database):
                self.cvss.write()
            self.cvss.read()
        return self

    def write(self):
        """ Save vulnerability's information into the database file
        The data will be stored in JSON and the file will be overwritten

        Return:
        the current class
        """
        with open(self.database, 'wb') as file:
            file.write('---\n'.encode('utf-8'))
            file.write('\n'.join([f'{key}: {self.data[key]}' for key in self.data]).encode('utf-8'))
            file.write('\n---\n\n'.encode('utf-8'))
            file.write(self.content.encode('utf-8'))
        self.cvss.write()
        return self

    def create(self):
        """ Create a new vulnerability

        Return:
        True if the vulnerability was created, False otherwise
        """
        if not os.path.isdir(os.path.dirname(self.database)):
            os.makedirs(os.path.dirname(self.database), exist_ok=True)
            os.makedirs(os.path.join(os.path.dirname(self.database), 'screenshots'), exist_ok=True)
            self.write()
            return True
        return False

    def delete(self):
        """ Delete the vulnerability

        Return:
        True if the vulnerability was deleted, False otherwise
        """
        try:
            shutil.rmtree(os.path.dirname(self.database))
            while os.path.isdir(os.path.dirname(self.database)):
                time.sleep(0.01)
        except:
            return False
        return True

    def rename(self, folder):
        """ Rename the vulnerability's folder

        Keyword arguments:
        folder -- the new folder

        Return:
        True if the vulnerability was moved, False otherwise
        """
        oldFolder = os.path.dirname(self.database)
        newFolder = os.path.join(os.path.dirname(oldFolder), os.path.basename(folder))
        if not os.path.isdir(newFolder):
            shutil.move(oldFolder, newFolder)
            self.database = os.path.join(os.path.abspath(newFolder), os.path.basename(self.database))
            self.cvss.database = os.path.join(os.path.abspath(newFolder), os.path.basename(self.cvss.database))
            return True
        return False

    def get(self, key, default = None):
        """ Getter for a project property

        Keyword arguments:
        key -- the name of the property
        default -- the value to return if the property does not exist

        Return:
        the value of the requested property
        """
        tmp = dict(map(lambda kv: (kv[0].lower(), kv[1]), self.data.items()))
        return tmp.get(key.lower(), default)

    def set(self, key, value):
        """ Setter for a project property

        Keyword arguments:
        key -- the name of the property
        value -- the value of the property
        """
        self.data[key] = value

    def basename(self):
        """ Return the base name of the project's pathname

        Return:
        the base name of the database file
        """
        return os.path.basename(self.dirname())

    def dirname(self):
        """ Return the directory name of the project's pathname

        Return:
        the directory name of the database file
        """
        return os.path.dirname(os.path.abspath(self.database))

    def relpath(self, path):
        """ Return a relative filepath to path from the project's folder

        Return:
        a relative filepath to path from the directory name of the database file
        """
        return os.path.relpath(path, self.dirname())

    @staticmethod
    def enum(root, database = 'info.md'):
        """ List all the directories in `root` that have the `database` file

        Keyword arguments:
        root -- the folder in which to search for vulnerabilities
        database -- the name of the database file that defines a vulnerability as such (default 'info.md')

        Return:
        an array of the found vulnerabilities
        """
        root = os.path.abspath(root)
        if os.path.isdir(root):
            return [os.path.dirname(f) for f in glob.glob(os.path.join(root, '*', database))]
        return []

    @staticmethod
    def isVulnerability(folder, database = 'info.md'):
        """ Check if the given folder is a valid vulnerability database

        Keyword arguments:
        folder -- the folder in which to save information and vulnerability's resources
        database -- the file to store vulnerability's information (default 'info.md')

        Return:
        True if the given folder contains the 'database' file, False otherwise
        """
        return os.path.isfile(os.path.join(os.path.abspath(folder), os.path.basename(database)))

    def getFilesList(self):
        """ Get taken screenshots

        Return:
        the list of taken screenshots
        """
        files = glob.glob(os.path.join(self.dirname(), '*'))
        files.remove(self.getScreenshotsDir())
        files.remove(os.path.abspath(self.database))
        files.remove(os.path.abspath(self.cvss.database))
        return [(file, os.path.isdir(file)) for file in files]

    def getScreenshotsDir(self):
        """ Get the screenshots folder for the current vulnerability

        Return:
        the absolute path of the screenshots folder
        """
        return os.path.join(os.path.dirname(self.database), 'screenshots')

    def sanitizeScreenshotPath(self, path):
        """ Sanitize a screenshot path to make sure it is in the appropriate folder

        Return:
        the sanitized path
        """
        return os.path.join(self.getScreenshotsDir(), os.path.basename(path))

    def getScreenshotsList(self):
        """ Get taken screenshots

        Return:
        the list of taken screenshots
        """
        if os.path.isdir(self.getScreenshotsDir()):
            return sorted([os.path.basename(f) for f in glob.glob(os.path.join(self.getScreenshotsDir(), '*.png'))])
        return []

    def countScreenshots(self):
        """ Count the number of screenshots taken

        Return:
        the number of PNG file in the screenshots folder
        """
        return len(self.getScreenshotsList())

    def takeScreenshot(self):
        """ Take a screenshot
        The used software is `scrot` and need to be installed
        """
        picture = None
        if not os.path.isdir(self.getScreenshotsDir()):
            os.makedirs(self.getScreenshotsDir(), exist_ok=True)
        if os.path.isfile('/usr/bin/scrot'):
            command = [
                '/usr/bin/scrot', 
                'Screenshot_%Y%m%d_%H%M%S.png', 
                '-e', f'mv "$f" "{self.getScreenshotsDir()}"; echo "$f"'
            ]
            with subprocess.Popen(command, stdout=subprocess.PIPE) as process:
                picture = process.stdout.read().decode('utf-8').strip('\n')
                picture = os.path.join(self.getScreenshotsDir(), picture)
        return picture

    @staticmethod
    def sanitizeVulnerabilityFolder(string):
        """ Sanitize string to use it as directory or file name
        - Replace spaces with underscores
        - Remove non-word characters (keep A-Z, a-z, 0-9 and _)
        - Check for any multiples underscores
        - Remove underscores at the beginning and the end of the string

        Keyword arguments:
        string -- the input string

        Return:
        the sanitized string
        """
        return re.sub(r'__+', '_', re.sub(r'[^A-Za-z0-9_]+', '', string.replace(' ', '_'))).strip('_')
